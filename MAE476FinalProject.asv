clc
clear
close all
tic
dt = 1;  % [s]
T_total = 6400; %[s]
t = 0:dt:T_total;
N = T_total/dt + 1;

a_inner = 7378.14; % [km]
a_outer = 8378.14; % [km]
i_inner = 80; % [deg]
i_outer = 60; % [deg]
inner_sats = satellite.empty(0,6);
inner_sats(1) = satellite(a_inner,i_inner,0,0);
inner_sats(2) = satellite(a_inner,i_inner,0,180);
inner_sats(3) = satellite(a_inner,i_inner,120,60);
inner_sats(4) = satellite(a_inner,i_inner,120,240);
inner_sats(5) = satellite(a_inner,i_inner,240,120);
inner_sats(6) = satellite(a_inner,i_inner,240,300);


outer_sats = satellite.empty(0,3);
outer_sats(1) = satellite(a_outer,i_outer,0,0);
outer_sats(2) = satellite(a_outer,i_outer,120,0);
outer_sats(3) = satellite(a_outer,i_outer,240,0);

servicer_1 = inner_sats(1);
servicer_2 = inner_sats(1);

inner_sat_pos = NaN(18,N);
outer_sat_pos = NaN(9,N);


%% Simulate Satellites (Assumptions)
for i=1:N

    for j=1:6 % Inner Sats
        % Logs values at each time step
        inner_sat_pos(3*j-2:3*j,i) = inner_sats(j).r;
        
        % propagate next time step
        inner_sats(j) = inner_sats(j).propagate(t(i));
        
    end

    for j = 1:3 % Outer Sats
        outer_sat_pos(3*j-2:3*j,i) = outer_sats(j).r;
        outer_sats(j) = outer_sats(j).propagate(dt);
    end
    
end

%% Simulate Satellites (ODE45)


%% Plan Maneuvers (Option 1)

% THIS SECTION SHOULD BE MOSTLY GOOD
% Servicer 1 (Staying in center)
tserv1_0 = 0;
dv_serv1 = 0;
    % Maneuver 1 (sat 1 -> sat 2)
    % Phase
    [dt1,dv1a,dv1b] = Phase(inner_sats(1),inner_sats(2));
    tserv1_1 = tserv1_0 + dt1;
    dv_serv1 = dv_serv1 + norm(dv1a) + norm(dv1b);
    servicer_1.phase(inner_sats(2));
    
    inner_sats(1).propagate(t_1);
    inner_sats(2).propagate(t_1);

    
    servicer_1.propagate(t_1);

    % Maneuver 2-3 (sat 2 -> sat 3)
    % Plane Change
    [tserv1_2,dv2] = Intercept(inner_sats(2),inner_sats(3),t_1);
    dv_serv1 = dv_serv1 + norm(dv2);
    inner_sats(2).propagate(tserv1_2);
    inner_sats(3).propagate(tserv1_2);

    servicer_1.propagate(tserv1_2);
    servicer_1.plane_change(inner_sats(3));

    % Phase
    [dt3,dv3a,dv3b] = Phase(inner_sats(2),inner_sats(3));
    tserv1_3 = tserv1_2 + dt3;
    dv_serv1 = dv_serv1 + norm(dv3a) + norm(dv);
    
    % Maneuver 4 (sat 3 -> sat 4)
    % Phase
    [dt4,dv4] = Phase(inner_sats(3),inner_sats(4));
    tserv1_4 = tserv1_3 + dt4;
    dv_serv1 = dv_serv1 + norm(dv4);

    % Maneuver 5-6 (sat 4 -> sat 5)
    % Plane Change
    [tserv1_5,dv5] = Intercept(inner_sats(4),inner_sats(5),tserv1_4);
    dv_serv1 = dv_serv1 + norm(dv5);
    inner_sats(4).propagate(tserv1_5);
    inner_sats(5).propagate(tserv1_5);
    % Phase
    [dt6,dv6] = Phase(inner_sats(3),inner_sats(4));
    tserv1_6 = tserv1_5 + dt6;
    dv_serv1 = dv_serv1 + norm(dv6);

    % Maneuver 7 (sat 5 -> sat 6)
    % Phase
    [dt7,dv7] = Phase(inner_sats(3),inner_sats(4));
    tserv1_7 = tserv1_6 + dt7;
    dv_serv1 = dv_serv1 + norm(dv7);

% THIS NEEDS WORK
% Servicer 2 (Going to outer ring)
    % Maneuver 8-10 (sat 1 -> sat 7)
    % Hohmann
    [dv8a,dv8b,dt8,dtheta8] = Hohmann(servicer_2,outer_sats(1));
    tserv2_1 = dt8;
    dv_serv2 = norm(dv8a) + norm(dv8b);

    % Plane Change
    [tserv2_2,dv9] = Intercept(servicer_2,outer_sats(1),tserv2_8);
    dv_serv2 = dv_serv2 + abs(dv9);

    % Phase
    [dt10,dv10] = Intercept(servicer_2,outer_sats(1),tserv2_2);
    dv_serv2 = dv_serv2 + abs(dv10);
    tserv2_3 = t_serv2_2 + dt10;
    % Maneuver 11 (sat 7 -> sat 8)
    % Plane Change
    [tserv2_4,dv11] = Intercept(servicer_2,outer_sats(2),tserv2_3);
    dv_serv2 = dv_serv2 + norm(dv11);

    % Maneuver 12 (sat 8 -> sat 9)
    % Plane Change
    [tserv2_5,dv12] = Intercept(servicer_2,outer_sats(3),tserv2_4);
    dv_serv2 = dv_serv2 + norm(dv12);
    dv = dv_serv1 + dv_serv2;

%% Plan Maneuvers (Option 2)

%% Calculate Masses
g0 = 9.81; % [m/s^2]
Isp = 250; %[s]
ms = 300; %[kg]
m_pay = 5; %[kg]
m_final2 = ms + m_pay;
ve = Isp * g0;

% Maneuver 2
mi = m_final2 / exp(-dv2*1000/ve);
m_prop2 = mi - m_final2;

% Maneuver 1
m_final1 = m_final2 + m_prop2;
mi1 = m_final1 / exp(-dv1*1000/ve);
m_prop1 = mi1 - m_final1;

% using func
dv_vec = [dv1 dv2];
[m_prop, m_history] = prop_mass(dv_vec, Isp, ms, m_pay);
% % Maneuver 12
% mi = m_final / exp(-dv12*1000/ve);
% m_prop12 = mi - m_final;
% 
% % Maneuver 11
% m_final = m_final + m_prop12;
% mi = m_final / exp(-dv11*1000/ve);
% m_prop11 = mi - m_final;
% 
% % Maneuver 10
% m_final = m_final + m_prop11;
% mi = m_final / exp(-dv11*1000/ve);
% m_prop11 = mi - m_final;


%% Simulate Maneuvers
for i = 1:N
% Maneuver 1

% Maneuver 2

% Maneuver 3

% Maneuver 4

% Maneuver 5

% Maneuver 6

% Maneuver 7

% Maneuver 8
end
toc

%% Figures
figure("Name","Constellation")
hold on
for i = 1:6
plot3(inner_sat_pos(3*i-2,:),inner_sat_pos(3*i-1,:),inner_sat_pos(3*i,:))
%plot3([0,inner_sat_h(3*i-2,1)],[0,inner_sat_h(3*i-1,1)],[0,inner_sat_h(3*i,1)])
end

for i = 1:3
plot3(outer_sat_pos(3*i-2,:),outer_sat_pos(3*i-1,:),outer_sat_pos(3*i,:))
end
view(3)
figure("Name","Servicer Path")

figure("Name","Pos Error")

%% Functions
% Hohmann transfer between 2 circular orbits around a given body
function [dv_1,dv_2,dt,dtheta] = Hohmann(sat1,sat2)
    v_1 = sqrt(sat1.mu/sat1.a);
    v_2 = sqrt(sat2.mu/sat2.a);
    a_t = (sat1.a + sat2.a)/2;

    dv_1 = sqrt(sat1.mu*(2/sat1.a -1/a_t)) - v_1; % initial delta v required (scalar)
    dv_2 = v_2 - sqrt(sat2.mu*(2/sat2.a -1/a_t)); % secondary delta v required (scalar)
    dt = pi*sqrt(a_t^3/sat2.mu); % TOF for transfer (scalar)
    dtheta = 2*pi*(dt/(2*pi*sqrt(sat2.a^3/sat1.mu))); % angle sat 2 sweeps during transfer
end

% Intersection of two co-radial circular orbits
function [t_intercept,dv] = Intercept(sat1,sat2,t_0)
    u1 = @(t) wrapTo360(sat1.u_0 + sat1.u_dot*t);
    u2 = @(t) wrapTo360(sat2.u_0 + sat2.u_dot*t);
    omega1 = @(t) sat1.omega_0 + sat1.omega_dot*t;
    omega2 = @(t) sat2.omega_0 + sat2.omega_dot*t;
    R_i = [1 0 0;
           0 cosd(-sat1.i)  sind(-sat1.i);
           0 sind(-sat1.i) -cosd(-sat1.i)];
    R_omega1 = @(t)[cosd(-omega1(t)), sind(-omega1(t)), 0;
                    sind(-omega1(t)),-cosd(-omega1(t)), 0;
                    0 0 1];
    R_omega2 = @(t)[cosd(-omega2(t)), sind(-omega2(t)), 0;
                    sind(-omega2(t)),-cosd(-omega2(t)), 0;
                    0 0 1];
    R_u1 = @(t) [cosd(-u1(t)), sind(-u1(t)), 0;...
                 sind(-u1(t)),-cosd(-u1(t)), 0;...
                 0           , 0           , 1];
    R_u2 = @(t) [cosd(-u2(t)), sind(-u2(t)), 0;...
                 sind(-u2(t)),-cosd(-u2(t)), 0;...
                 0           , 0           , 1];

    r1 = @(t)R_omega1(t)*R_i*R_u1(t)*[sat1.a;0;0];
    r2 = @(t)R_omega2(t)*R_i*R_u2(t)*[sat2.a;0;0];

    v1 = @(t)R_omega1(t)*R_i*R_u1(t)*sqrt(sat1.mu/sat1.a)*[0;1;0];
    v2 = @(t)R_omega2(t)*R_i*R_u2(t)*sqrt(sat2.mu/sat2.a)*[0;1;0];

    h1 = @(t) cross(r1(t),v1(t));
    h2 = @(t) cross(r2(t),v2(t));
    r_intercept = @(t) sat1.a*cross(h1(t),h2(t))/norm(cross(h1(t),h2(t)));
    separation = @(t) min(norm(r_intercept(t) - r1(t)),norm(-r_intercept(t) - r1(t)));

    t_intercept = fsolve(separation,t_0);
    if (t_intercept < t_0)
        t_0 = t_intercept + 0.5*sat1.T;
        t_intercept = fsolve(separation,t_0);
    end
    delta = acosd(cos(sat1.i)^2 +sind(sat1.i)^2*cosd(sat2.omega - sat1.omega));
    dv = 2*sqrt(sat1.mu/sat1.a)*sin(delta/2);
end

% Phase maneuver between circular orbits
function [dt,dv] = Phase(sat1,sat2)

    phase_angle = sat2.u - sat1.u;
    dt = sat2.T* (1 + phase_angle/360);
    a_phase = (sat1.mu * (dt/2*pi)^2)^(1/3);
    dv = 2* abs(sqrt(sat2.mu*(2/sat2.a - 1/a_phase)) - sqrt(sat2.mu/sat2.a));
end

% Calculate Mass 
function [m_prop, m_final, m_initial] = prop_mass(dv, Isp, ms, m_pay)
% dv     = vector of maneuvers [dv1 dv2 ... dvN] in km/s
% Isp    = specific impulse [s]
% ms     = structural mass [kg]
% m_pay  = payload mass [kg]
%
% m_prop    = propellant used at each maneuver [kg]
% m_final   = total mass AFTER each maneuver [kg]
% m_initial = total mass BEFORE each maneuver [kg]

    g0 = 9.81;           % [m/s^2]
    ve = Isp * g0;       % exhaust velocity [m/s]

    N = length(dv);

    m_prop    = zeros(1, N);
    m_final   = zeros(1, N);
    m_initial = zeros(1, N);
    m_final(N) = ms + m_pay;
    
    for k = N:-1:1

        mi = m_final(k) / exp(-dv(k)*1000/ve);
        m_prop(k) = mi - m_final(k);
        m_initial(k) = mi;

        % Update the final mass for the previous maneuver
        if k > 1
            m_final(k-1) = m_final(k) + m_prop(k);
        end
    end
end

